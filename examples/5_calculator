class CalcError : Error {
  pub pos: int

  init (message: str, pos: int) {
    super(message)
    this.pos = pos
  }
}

union Expr = Literal | BinaryExpr | UnaryExpr

obj Literal {
  end: int
  start: int
  val: float | int
}

obj BinaryExpr {
  end: int
  left: Expr
  operator: str
  right: Expr
  start: int
}

obj UnaryExpr {
  expr: Expr
  end: int
  operator: str
  start: int
}

obj Token {
  end: int
  start: int
  type: TokenType
  val: str
}

enum TokenType {
  operand,
  operator
}

fn tokenize (input: str) Token[] {
  mut tokens: Token[]
  mut start := 0
  mut val := ''

  loop i, ch in input {
    if ch.digit || ch == '.' {
      if val.empty {
        start = i
      }

      val += ch

      if i != input.length - 1 && (input[i + 1].digit || input[i + 1] == '.') {
        continue
      }

      tokens.push({ end: i, start, type: .operand, val })
      val = ''
    } elif ['/', '*', '-', '+'].includes(ch) {
      tokens.push({ end: i + 1, start: i, type: .operator, val: ch })
    } elif ![' ', '\t'].includes(ch) {
      throw new CalcError('Unexpected token', i)
    }
  }

  return tokens
}

fn parse (tokens: Token[], expr: Expr?, pos := 0) Expr {
  // TODO
}

fn evaluate (expr: Expr) str {
  // TODO
}

main {
  loop {
    print('> ')
    line := program.stdin.readline().trim()

    if line == 'exit' || line == '\\q' {
      break
    }

    try {
      tokens := tokenize(line)
      expr := parse(tokens)
      output := evaluate(expr)

      if !output.empty {
        print(output)
      }
    } catch CalcError err {
      print(' '.times(err.pos) + "^ ${err.message}")
    }
  }
}
