export enum Signal {
  abrt,
  alrm,
  brk,
  bus,
  chld,
  cont,
  fpe,
  hup,
  ill,
  int,
  io,
  kill,
  lost,
  pipe,
  prof,
  pwr,
  quit,
  segv,
  stkflt,
  stop,
  sys,
  term,
  trap,
  tstp,
  ttin,
  ttou,
  urg,
  usr1,
  usr2,
  vtalrm,
  winch,
  xcpu,
  xfsz
}

interface Any {
  op str () str
}

interface Array<T> : Any {
  empty: bool
  len: int

  op + (rhs: T) Array<T>
  op + (rhs: Array<T>) Array<T>
  mut op += (rhs: T) this
  mut op += (rhs: Array<T>) this
  op [] (i: int) T
  mut op [] (i: int) mut T
  op [] (slice: Slice) Array<T>
  op iter () Iterator<int, T>
  mut op iter () Iterator<int, mut T>

  includes (x: T) bool
  index (x: T) int?
  mut pop () T?
  mut push (n: T) this
  mut remove (at: int) T
  mut reverse () this
  mut shift () T?
  mut unshift (n: T) this
}

interface Boolean : Any {
}

interface Byte : Any {
  op + (rhs: byte) byte
}

interface Char : Any {
  digit: bool

  op + (rhs: char) str
  op + (rhs: str) str

  times (n: int) str
}

interface Function : Any {
}

interface Number : Any {
  op + (rhs: Number) Number
  op + (rhs: char) str
  op + (rhs: str) str
  op - (rhs: Number) Number
  op / (rhs: Number) Number
  op * (rhs: Number) Number
  op % (rhs: Number) Number
  op += (rhs: Number) this
  op -= (rhs: Number) this
  op /= (rhs: Number) this
  op *= (rhs: Number) this
  op %= (rhs: Number) this
}

interface Object : Any {
}

interface Optional<T> : Any {
}

interface Range : Any {
  end: int
  start: int

  op iter () Iterator<int, int>
  mut op iter () Iterator<int, mut int>
}

interface Slice : Any {
  end: int?
  start: int?
  step: int?
}

interface String : Any {
  empty: bool
  len: int

  op + (rhs: char) str
  op + (rhs: str) str
  mut op += (rhs: char) this
  mut op += (rhs: str) this
  op [] (i: int) char
  mut op [] (i: int) mut char
  op [] (slice: Slice) str
  op iter () Iterator<int, char>
  mut op iter () Iterator<int, mut char>

  mut clear () this
  includes (x: char) bool
  includes (x: str) bool
  index (x: char) int?
  index (x: str) int?
  mut reverse () this
  times (n: int) str
}

obj Program {
  args: str[]
  cwd: str
  env: Map<str, str>
  pid: int
}

export class Error {
  pub message: str
  pub name: str

  init (message: str) this
}

export class Iterator<T, U> {
  pub cursor: T

  pub hasNext () bool
  pub next () U
  pub mut next () mut U
}

export class Map<T, U> {
  pub size: int

  op iter () Iterator<T, U>
  mut op iter () Iterator<T, mut U>
  op str () str

  pub mut delete (key: T) this
  pub get (key: T) U?
  pub mut get (key: T) mut U?
  pub has (key: T) bool
  pub mut set (key: T, val: U) this
}

export fn exit (code: int) void
export fn kill (pid: int, sig := Signal.term) void
export fn print (items: any..., separator := " ", terminator := "\n") void
export fn sleep (ms: int) async void

export program: Program
